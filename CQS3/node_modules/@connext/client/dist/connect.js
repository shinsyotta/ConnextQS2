"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const messaging_1 = require("@connext/messaging");
const types_1 = require("@connext/types");
require("core-js/stable");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const hdnode_1 = require("ethers/utils/hdnode");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
require("regenerator-runtime/runtime");
const channelProvider_1 = require("./channelProvider");
const connext_1 = require("./connext");
const lib_1 = require("./lib");
const node_1 = require("./node");
const types_2 = require("./types");
const exists = (obj) => {
    return !!obj && !!Object.keys(obj).length;
};
const createMessagingService = (messagingUrl, logLevel) => __awaiter(this, void 0, void 0, function* () {
    const messagingFactory = new messaging_1.MessagingServiceFactory({ logLevel, messagingUrl });
    const messaging = messagingFactory.createService("messaging");
    yield messaging.connect();
    return messaging;
});
const setupMultisigAddress = (node, channelProvider, log) => __awaiter(this, void 0, void 0, function* () {
    const myChannel = yield node.getChannel();
    let multisigAddress;
    if (!myChannel) {
        log.debug("no channel detected, creating channel..");
        const creationEventData = yield Promise.race([
            new Promise((res) => __awaiter(this, void 0, void 0, function* () {
                channelProvider.once(types_2.CFCoreTypes.EventNames.CREATE_CHANNEL_EVENT, (data) => {
                    res(data.data);
                });
                const creationData = yield node.createChannel();
                log.debug(`created channel, transaction: ${lib_1.stringify(creationData)}`);
            })),
            lib_1.delayAndThrow(30000, "Create channel event not fired within 30s"),
        ]);
        multisigAddress = creationEventData.multisigAddress;
    }
    else {
        multisigAddress = myChannel.multisigAddress;
    }
    log.debug(`multisigAddress: ${multisigAddress}`);
    channelProvider.multisigAddress = multisigAddress;
    return channelProvider;
});
exports.connect = (opts) => __awaiter(this, void 0, void 0, function* () {
    const { logLevel, ethProviderUrl, nodeUrl, store, mnemonic, channelProvider: providedChannelProvider, } = opts;
    let { xpub, keyGen } = opts;
    const log = new lib_1.Logger("ConnextConnect", logLevel);
    log.debug(`Creating ethereum provider - ethProviderUrl: ${ethProviderUrl}`);
    const ethProvider = new ethers_1.providers.JsonRpcProvider(ethProviderUrl);
    const network = yield ethProvider.getNetwork();
    if (network.chainId === 4447) {
        network.name = "ganache";
        ethProvider.getSigner = (addressOrIndex) => {
            throw { code: "UNSUPPORTED_OPERATION" };
        };
    }
    let messaging;
    let node;
    let config;
    let channelProvider;
    let isInjected = false;
    if (providedChannelProvider) {
        channelProvider = providedChannelProvider;
        if (!exists(channelProvider.config)) {
            yield channelProvider.enable();
        }
        log.debug(`Using channelProvider config: ${lib_1.stringify(channelProvider.config)}`);
        log.debug(`Creating messaging service client ${channelProvider.config.nodeUrl}`);
        messaging = yield createMessagingService(channelProvider.config.nodeUrl, logLevel);
        node = new node_1.NodeApiClient({ logLevel, messaging, channelProvider });
        config = yield node.config();
        log.debug(`Node provided config: ${lib_1.stringify(config)}`);
        node.channelProvider = channelProvider;
        node.userPublicIdentifier = channelProvider.config.userPublicIdentifier;
        node.nodePublicIdentifier = config.nodePublicIdentifier;
        isInjected = true;
    }
    else if (mnemonic || (xpub && keyGen)) {
        if (!store) {
            throw new Error("Client must be instantiated with store if not using a channelProvider");
        }
        if (!nodeUrl) {
            throw new Error("Client must be instantiated with nodeUrl if not using a channelProvider");
        }
        if (mnemonic) {
            log.debug(`Creating channelProvider with mnemonic: ${mnemonic}`);
            const hdNode = hdnode_1.fromExtendedKey(hdnode_1.fromMnemonic(mnemonic).extendedKey).derivePath(types_1.CF_PATH);
            xpub = hdNode.neuter().extendedKey;
            keyGen = (index) => Promise.resolve(hdNode.derivePath(index).privateKey);
        }
        else {
            log.debug(`Creating channelProvider with xpub: ${xpub}`);
            log.debug(`Creating channelProvider with keyGen: ${keyGen}`);
        }
        log.debug(`Creating messaging service client ${nodeUrl}`);
        messaging = yield createMessagingService(nodeUrl, logLevel);
        node = new node_1.NodeApiClient({ logLevel, messaging });
        config = yield node.config();
        log.debug(`Node provided config: ${lib_1.stringify(config)}`);
        channelProvider = yield channelProvider_1.createCFChannelProvider({
            ethProvider,
            keyGen,
            lockService: { acquireLock: node.acquireLock.bind(node) },
            messaging: messaging,
            networkContext: config.contractAddresses,
            nodeConfig: { STORE_KEY_PREFIX: types_2.ConnextClientStorePrefix },
            nodeUrl,
            store,
            xpub,
        });
        log.debug(`Using channelProvider config: ${lib_1.stringify(channelProvider.config)}`);
        node.channelProvider = channelProvider;
        node.userPublicIdentifier = channelProvider.config.userPublicIdentifier;
        node.nodePublicIdentifier = config.nodePublicIdentifier;
    }
    else {
        throw new Error(`Client must be instantiated with xpub and keyGen, or a channelProvider if not using mnemonic`);
    }
    yield setupMultisigAddress(node, channelProvider, log);
    const token = new ethers_1.Contract(config.contractAddresses.Token, human_standard_token_abi_1.default, ethProvider);
    const appRegistry = yield node.appRegistry();
    const client = new connext_1.ConnextClient(Object.assign({ appRegistry,
        channelProvider,
        config,
        ethProvider,
        keyGen,
        messaging,
        network,
        node,
        store,
        token }, opts));
    if (isInjected) {
        return client;
    }
    try {
        yield client.getFreeBalance();
    }
    catch (e) {
        if (e.message.includes(`StateChannel does not exist yet`)) {
            log.debug(`Restoring client state: ${e.stack || e.message}`);
            yield client.restoreState();
        }
        else {
            log.error(`Failed to get free balance: ${e.stack || e.message}`);
            throw e;
        }
    }
    const { data: sc } = yield client.getStateChannel();
    if (!sc.proxyFactoryAddress) {
        log.debug(`No proxy factory address found, restoring client state`);
        yield client.restoreState();
    }
    log.debug("Registering subscriptions");
    yield client.registerSubscriptions();
    yield client.cleanupRegistryApps();
    yield client.uninstallCoinBalanceIfNeeded(constants_1.AddressZero);
    yield client.uninstallCoinBalanceIfNeeded(config.contractAddresses.Token);
    log.debug("Resubmitting active withdrawals");
    yield client.resubmitActiveWithdrawal();
    log.debug("Reclaiming pending async transfers");
    yield client.reclaimPendingAsyncTransfers();
    yield client.clientCheckIn();
    log.debug("Done creating channel client");
    return client;
});
//# sourceMappingURL=connect.js.map