"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const eccrypto_1 = require("eccrypto");
const secp256k1_1 = require("secp256k1");
const compress = (pubKey) => {
    const startsWith04 = Buffer.from(pubKey.replace(/^0x/, ""), "hex").length === 64
        ? `04${pubKey.replace(/^0x/, "")}`
        : pubKey.replace(/^0x/, "");
    return secp256k1_1.publicKeyConvert(Buffer.from(startsWith04, "hex"), true).toString("hex");
};
const decompress = (pubKey) => {
    const prefixed = Buffer.from(pubKey, "hex").length === 64 ? `04${pubKey}` : pubKey;
    return secp256k1_1.publicKeyConvert(Buffer.from(prefixed.replace(/^0x/, ""), "hex"), false)
        .toString("hex")
        .substring(2);
};
exports.encryptWithPublicKey = (publicKey, message) => __awaiter(this, void 0, void 0, function* () {
    const key = `04${decompress(publicKey)}`;
    const encryptedBuffers = yield eccrypto_1.encrypt(Buffer.from(key, "hex"), Buffer.from(message));
    const encrypted = {
        ciphertext: encryptedBuffers.ciphertext.toString("hex"),
        ephemPublicKey: encryptedBuffers.ephemPublicKey.toString("hex"),
        iv: encryptedBuffers.iv.toString("hex"),
        mac: encryptedBuffers.mac.toString("hex"),
    };
    return Buffer.concat([
        Buffer.from(encrypted.iv, "hex"),
        Buffer.from(compress(encrypted.ephemPublicKey), "hex"),
        Buffer.from(encrypted.mac, "hex"),
        Buffer.from(encrypted.ciphertext, "hex"),
    ]).toString("hex");
});
exports.decryptWithPrivateKey = (privateKey, message) => __awaiter(this, void 0, void 0, function* () {
    const buf = Buffer.from(message, "hex");
    const encrypted = {
        ciphertext: buf.toString("hex", 81, buf.length),
        ephemPublicKey: `04${decompress(buf.toString("hex", 16, 49))}`,
        iv: buf.toString("hex", 0, 16),
        mac: buf.toString("hex", 49, 81),
    };
    const decryptedBuffer = yield eccrypto_1.decrypt(Buffer.from(privateKey.replace(/^0x/, ""), "hex"), {
        ciphertext: Buffer.from(encrypted.ciphertext, "hex"),
        ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, "hex"),
        iv: Buffer.from(encrypted.iv, "hex"),
        mac: Buffer.from(encrypted.mac, "hex"),
    });
    return decryptedBuffer.toString();
});
//# sourceMappingURL=crypto.js.map