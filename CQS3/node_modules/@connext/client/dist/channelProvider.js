"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const lib_1 = require("./lib");
exports.createCFChannelProvider = ({ ethProvider, keyGen, lockService, messaging, networkContext, nodeConfig, nodeUrl, store, xpub, }) => __awaiter(this, void 0, void 0, function* () {
    const cfCore = yield lib_1.CFCore.create(messaging, store, networkContext, nodeConfig, ethProvider, lockService, xpub, keyGen);
    const channelProviderConfig = {
        freeBalanceAddress: lib_1.xpubToAddress(xpub),
        nodeUrl,
        signerAddress: lib_1.xpubToAddress(xpub),
        userPublicIdentifier: xpub,
    };
    const channelProvider = new ChannelProvider(cfCore, channelProviderConfig, store, yield keyGen("0"));
    return channelProvider;
});
class ChannelProvider {
    constructor(connection, config, store, authKey) {
        this._multisigAddress = undefined;
        this._signerAddress = undefined;
        this.enable = () => __awaiter(this, void 0, void 0, function* () {
            return this.config;
        });
        this.send = (method, params = {}) => __awaiter(this, void 0, void 0, function* () {
            let result;
            switch (method) {
                case "chan_storeSet":
                    result = yield this.set(params.pairs);
                    break;
                case "chan_storeGet":
                    result = yield this.get(params.path);
                    break;
                case "chan_nodeAuth":
                    result = yield this.signMessage(params.message);
                    break;
                case "chan_config":
                    result = this.config;
                    break;
                case "chan_restoreState":
                    result = yield this.restoreState(params.path);
                    break;
                default:
                    result = yield this._send(method, params);
                    break;
            }
            return result;
        });
        this.on = (event, listener) => {
            this.connection.on(event, listener);
            return this.connection;
        };
        this.once = (event, listener) => {
            this.connection.once(event, listener);
            return this.connection;
        };
        this.signMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            return yield this.wallet.signMessage(utils_1.arrayify(message));
        });
        this.get = (path) => __awaiter(this, void 0, void 0, function* () {
            return yield this.store.get(path);
        });
        this.set = (pairs, allowDelete) => __awaiter(this, void 0, void 0, function* () {
            return yield this.store.set(pairs, allowDelete);
        });
        this.restore = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.store.restore();
        });
        this.reset = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.store.reset();
        });
        this.restoreState = (path) => __awaiter(this, void 0, void 0, function* () {
            this.reset();
            let state;
            state = yield this.restore();
            if (!state || !state.path) {
                throw new Error(`No matching paths found in store backup's state`);
            }
            state = state.path;
            return state;
        });
        this._send = (methodName, parameters) => __awaiter(this, void 0, void 0, function* () {
            const ret = yield this.connection.rpcRouter.dispatch({
                id: Date.now(),
                methodName,
                parameters: lib_1.deBigNumberifyJson(parameters),
            });
            const result = ret.result.result;
            return result;
        });
        this.store = store;
        this.wallet = authKey ? new ethers_1.Wallet(authKey) : null;
        this.connection = connection;
        this._config = config;
        this._multisigAddress = config.multisigAddress;
        this._signerAddress = config.signerAddress;
    }
    get isSigner() {
        return true;
    }
    get config() {
        return this._config;
    }
    get multisigAddress() {
        return this._multisigAddress || this.config.multisigAddress;
    }
    set multisigAddress(multisigAddress) {
        this._config.multisigAddress = multisigAddress;
        this._multisigAddress = multisigAddress;
    }
    get signerAddress() {
        return this._signerAddress || this.config.signerAddress;
    }
    set signerAddress(signerAddress) {
        this._config.signerAddress = signerAddress;
        this._signerAddress = signerAddress;
    }
}
exports.ChannelProvider = ChannelProvider;
//# sourceMappingURL=channelProvider.js.map